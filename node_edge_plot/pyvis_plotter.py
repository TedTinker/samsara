#%% 
import os
from pyvis.network import Network
import networkx as nx

# Helper function to convert RGB to hex
def rgb_to_hex(color):
    if isinstance(color, tuple) and len(color) == 3:
        return '#{:02x}{:02x}{:02x}'.format(*color)
    return color  # If it's already a valid color (e.g., "red" or "#FF5733"), return as is

def create_interactive_network_html(nodes, edges, output_file="interactive_network.html"):
    # Create a NetworkX graph and add nodes and edges with labels, colors, sizes, widths, shapes, arrows, and lengths
    G = nx.Graph()
    for node, color, size, shape in nodes:
        color_hex = rgb_to_hex(color)
        G.add_node(node, color={"background": color_hex, "border": color_hex}, size=size, shape=shape)
    
    for src, dst, color, width, arrows, length, label in edges:
        G.add_edge(src, dst, label=label, color=rgb_to_hex(color), width=width, arrows=arrows, length=length)
    
    # Initialize pyvis Network and build from NetworkX graph
    net = Network(notebook=True, directed=False)
    for node, color, size, shape in nodes:
        color_hex = rgb_to_hex(color)
        net.add_node(node, label=node, color={"background": color_hex, "border": color_hex}, size=size, shape=shape)
    
    for src, dst, color, width, arrows, length, label in edges:
        arrow_type = None
        if arrows == "to":
            arrow_type = "to"
        elif arrows == "from":
            arrow_type = "from"
        elif arrows == "both":
            arrow_type = "to,from"
        edge_options = {
            'label': label,
            'color': rgb_to_hex(color),
            'width': width,
            'arrows': arrow_type,
            'length': length,
        }
        if src == dst:
            # Adjust the self-loop size using selfReferenceSize
            edge_options['selfReferenceSize'] = length / 5  # Adjust the divisor as needed
        net.add_edge(src, dst, **edge_options)
    
    # Save the basic visualization to HTML using pyvis
    base_html = "network_base.html"
    net.show(base_html)
    
    # Read the base HTML generated by pyvis
    with open(base_html, "r") as file:
        html_content = file.read()
    
    # Custom CSS to make the network container fill the entire window
    css_style = """
<style>
    #mynetwork {
        width: 100%;
        height: 100vh;
    }
</style>
"""
    
    # Generate dynamic buttons and toggle function based on nodes and edges
    button_html = "<div>\n"
    for node, color, size, shape in nodes:
        button_html += f'    <button onclick="toggleNode(\'{node}\')">Toggle {node}</button>\n'
    button_html += "</div>\n\n"
    
    # Define the toggleNode function dynamically to add/remove nodes and edges with colors, sizes, shapes, arrows, and lengths
    toggle_function = """
<script type="text/javascript">
    function toggleNode(nodeId) {
        if (network.body.data.nodes.get(nodeId)) {
            network.body.data.nodes.remove(nodeId);  // Remove node
            network.body.data.edges.remove(network.body.data.edges.get({
                filter: function (edge) {
                    return edge.from === nodeId || edge.to === nodeId;
                }
            }));
        } else {
"""
    # Add nodes dynamically with colors, sizes, and shapes
    toggle_function += "            let nodes = {\n"
    for node, color, size, shape in nodes:
        color_hex = rgb_to_hex(color)  # Convert color to hex if needed
        toggle_function += f"                '{node}': {{id: '{node}', label: '{node}', color: {{background: '{color_hex}', border: '{color_hex}'}}, size: {size}, shape: '{shape}'}},\n"
    toggle_function += "            };\n"
    toggle_function += "            network.body.data.nodes.add(nodes[nodeId]);\n"
    
    # Generate edges dictionary dynamically for reconnection with labels, colors, widths, arrows, and lengths
    toggle_function += "            let edges = {\n"
    for src, dst, color, width, arrows, length, label in edges:
        color_hex = rgb_to_hex(color)  # Convert color to hex if needed
        arrow_type = "null"
        if arrows == "to":
            arrow_type = "to"
        elif arrows == "from":
            arrow_type = "from"
        elif arrows == "both":
            arrow_type = "to,from"
        edge_params = f"from: '{src}', to: '{dst}', label: '{label}', color: '{color_hex}', width: {width}, arrows: '{arrow_type}', length: {length}"
        if src == dst:
            # Adjust the self-loop size using selfReferenceSize
            edge_params += f", selfReferenceSize: {length / 5}"  # Adjust the divisor as needed
        toggle_function += f"                '{src}-{dst}': {{{edge_params}}},\n"
    toggle_function += "            };\n"

    # Add JavaScript to re-add edges connected to the node being toggled with labels, colors, widths, arrows, and lengths
    toggle_function += """
            for (let key in edges) {
                let edge = edges[key];
                if ((edge.from === nodeId || edge.to === nodeId) &&
                    !network.body.data.edges.get().find(e => e.from === edge.from && e.to === edge.to)) {
                    network.body.data.edges.add(edge);
                }
            }
        }
    }
</script>
"""

    # Combine everything: base HTML, CSS, button HTML, and toggle function
    full_html = html_content.replace("<body>", "<body>" + css_style + button_html + toggle_function)
    
    # Write the combined HTML to the output file
    with open(output_file, "w") as file:
        file.write(full_html)
        
    # Remove the temporary base HTML file
    os.remove(base_html)

    print(f"Interactive network with toggle buttons saved as {output_file}")

if __name__ == "__main__":
    # RGB colors are now supported in both nodes and edges
    nodes = [
        ("A", (255, 0, 0), 20, "star"), 
        ("B", (0, 0, 255), 15, "dot"), 
        ("C", (0, 255, 0), 25, "triangle"), 
        ("D", (128, 0, 128), 10, "square")
    ]
    edges = [
        ("A", "B", (255, 165, 0), 3, "to", 300, "A-B"), 
        ("A", "C", (128, 128, 128), 2, "from", 200, "A-C"), 
        ("B", "D", (0, 0, 0), 5, "both", 250, "B-D"), 
        ("C", "D", (0, 255, 255), 4, "none", 150, "C-D"),
        # Add a self-loop edge
        ("A", "A", (255, 0, 0), 2, "to", 100, "A-A")
    ]
    create_interactive_network_html(nodes, edges)
