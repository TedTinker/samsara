#%% 
import os
import json
from pyvis.network import Network
import networkx as nx

# Helper function to convert RGB to hex
def rgb_to_hex(color):
    if isinstance(color, tuple) and len(color) == 3:
        return '#{:02x}{:02x}{:02x}'.format(*color)
    return color  # If it's already a valid color (e.g., "red" or "#FF5733"), return as is

def create_interactive_network_html(nodes, edges, output_file="interactive_network.html"):
    # Create a NetworkX graph and add nodes and edges with labels, colors, sizes, widths, shapes, arrows, and lengths
    G = nx.Graph()
    for node, color, size, shape in nodes:
        color_hex = rgb_to_hex(color)
        G.add_node(node, color={"background": color_hex, "border": color_hex}, size=size, shape=shape)
    
    for src, dst, color, width, arrows, length, label in edges:
        G.add_edge(src, dst, label=label, color=rgb_to_hex(color), width=width, arrows=arrows, length=length)
    
    # Initialize pyvis Network and build from NetworkX graph
    net = Network(notebook=True, directed=False)
    for node, color, size, shape in nodes:
        color_hex = rgb_to_hex(color)
        net.add_node(node, label=node, color={"background": color_hex, "border": color_hex}, size=size, shape=shape)
    
    for src, dst, color, width, arrows, length, label in edges:
        arrow_type = None
        if arrows == "to":
            arrow_type = "to"
        elif arrows == "from":
            arrow_type = "from"
        elif arrows == "both":
            arrow_type = "to,from"
        edge_options = {
            'label': label,
            'color': rgb_to_hex(color),
            'width': width,
            'arrows': arrow_type,
            'length': length,
        }
        if src == dst:
            # Adjust the self-loop size using selfReferenceSize
            edge_options['selfReferenceSize'] = length / 5  # Adjust the divisor as needed
        net.add_edge(src, dst, **edge_options)
    
    # Save the basic visualization to HTML using pyvis
    base_html = "network_base.html"
    net.show(base_html)
    
    # Read the base HTML generated by pyvis
    with open(base_html, "r") as file:
        html_content = file.read()
    
    # Custom CSS to make the network container fill the entire window
    css_style = """
<style>
    #mynetwork {
        width: 100%;
        height: 100vh;
    }
</style>
"""
    
    # Generate dynamic buttons and toggle function based on nodes and edges
    button_html = "<div>\n"
    for node, color, size, shape in nodes:
        button_html += f'    <button onclick="toggleNode(\'{node}\')">Toggle {node}</button>\n'
    button_html += "</div>\n\n"
    
    # Create nodes and edges dictionaries and serialize them to JSON
    nodes_dict = {}
    for node, color, size, shape in nodes:
        color_hex = rgb_to_hex(color)
        nodes_dict[node] = {
            'id': node,
            'label': node,
            'color': {'background': color_hex, 'border': color_hex},
            'size': size,
            'shape': shape
        }

    edges_dict = {}
    for src, dst, color, width, arrows, length, label in edges:
        color_hex = rgb_to_hex(color)
        arrow_type = None
        if arrows == "to":
            arrow_type = {"to": True}
        elif arrows == "from":
            arrow_type = {"from": True}
        elif arrows == "both":
            arrow_type = {"to": True, "from": True}
        edge_data = {
            'from': src,
            'to': dst,
            'label': label,
            'color': color_hex,
            'width': width,
            'arrows': arrow_type,
            'length': length
        }
        if src == dst:
            edge_data['selfReferenceSize'] = length / 5  # Adjust the divisor as needed
        edge_key = f"{src}-{dst}"
        edges_dict[edge_key] = edge_data
    
    # Define the toggleNode function with serialized JSON data
    toggle_function = f"""
<script type="text/javascript">
    function toggleNode(nodeId) {{
        if (network.body.data.nodes.get(nodeId)) {{
            network.body.data.nodes.remove(nodeId);  // Remove node
            network.body.data.edges.remove(network.body.data.edges.get({{
                filter: function (edge) {{
                    return edge.from === nodeId || edge.to === nodeId;
                }}
            }}));
        }} else {{
            let nodes = {json.dumps(nodes_dict)};
            let edges = {json.dumps(edges_dict)};
            network.body.data.nodes.add(nodes[nodeId]);
            for (let key in edges) {{
                let edge = edges[key];
                if ((edge.from === nodeId || edge.to === nodeId) &&
                    !network.body.data.edges.get().find(e => e.from === edge.from && e.to === edge.to)) {{
                    network.body.data.edges.add(edge);
                }}
            }}
        }}
    }}
</script>
"""
    
    # Combine everything: base HTML, CSS, button HTML, and toggle function
    full_html = html_content.replace("<body>", "<body>" + css_style + button_html + toggle_function)
    
    # Write the combined HTML to the output file
    with open(output_file, "w") as file:
        file.write(full_html)
        
    # Remove the temporary base HTML file
    os.remove(base_html)

    print(f"Interactive network with toggle buttons saved as {output_file}")




if __name__ == "__main__":
    # RGB colors are now supported in both nodes and edges
    nodes = [
        ("A", (255, 0, 0), 20, "star"), 
        ("B", (0, 0, 255), 15, "dot"), 
        ("C", (0, 255, 0), 25, "triangle"), 
        ("D", (128, 0, 128), 10, "square")
    ]
    edges = [
        ("A", "B", (255, 165, 0), 3, "to", 300, "A-B"), 
        ("A", "C", (128, 128, 128), 2, "from", 200, "A-C"), 
        ("B", "D", (0, 0, 0), 5, "both", 250, "B-D"), 
        ("C", "D", (0, 255, 255), 4, "none", 150, "C-D"),
        # Add a self-loop edge
        ("A", "A", (255, 0, 0), 2, "to", 100, "A-A")
    ]
    create_interactive_network_html(nodes, edges)
